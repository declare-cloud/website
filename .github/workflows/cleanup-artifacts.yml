name: Cleanup Artifacts

on:
  schedule:
    - cron: '0 0 * * *' # Daily at midnight UTC
  delete:
  push:
    branches:
      - main
      - 'pr/**'
  workflow_dispatch:

env:
  PACKAGE_NAME: website
  PR_TAG_PREFIX: 0.0.0-pr-
  DEV_TAG_PREFIX: dev-

jobs:
  cleanup-container:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read

    steps:
      - name: Delete container images for PRs, old main builds, and untagged
        uses: actions/github-script@v7
        with:
          script: |
            const packageName = process.env.PACKAGE_NAME;
            const prTagPrefix = process.env.PR_TAG_PREFIX;
            const devTagPrefix = process.env.DEV_TAG_PREFIX;
            const branchName = context.payload?.ref?.replace(/^refs\/heads\//, '').replace(/\//g, '-');

            try {
              const versions = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                package_type: 'container',
                package_name: packageName,
                org: context.repo.owner
              });

              const mainBuilds = [];

              for (const v of versions.data) {
                const tags = v.metadata?.container?.tags || [];

                const isTaggedRelease = tags.some(t => /^v\d+\.\d+\.\d+$/.test(t));
                const isMainDev = tags.some(t => t.startsWith(devTagPrefix));
                const isPR = branchName
                  ? tags.some(t => t.includes(branchName) || t.startsWith(prTagPrefix))
                  : tags.some(t => t.startsWith(prTagPrefix));
                const isUntagged = tags.length === 0;

                if (!isTaggedRelease && (isPR || isUntagged)) {
                  console.log(`Deleting container version ${v.id} (tags: ${tags.join(', ') || 'untagged'})`);
                  await github.rest.packages.deletePackageVersionForOrg({
                    package_type: 'container',
                    package_name: packageName,
                    org: context.repo.owner,
                    package_version_id: v.id
                  });
                } else if (isMainDev) {
                  mainBuilds.push(v);
                }
              }

              mainBuilds.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
              const oldMain = mainBuilds.slice(5);
              for (const v of oldMain) {
                console.log(`Deleting old main container build ${v.id}`);
                await github.rest.packages.deletePackageVersionForOrg({
                  package_type: 'container',
                  package_name: packageName,
                  org: context.repo.owner,
                  package_version_id: v.id
                });
              }
            } catch (error) {
              if (error.status === 404) {
                console.log(`Container package not found: ${error.message}`);
              } else {
                throw error;
              }
            }

  cleanup-helm:
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read

    steps:
      - name: Delete Helm charts for PRs, old main builds, and untagged
        uses: actions/github-script@v7
        with:
          script: |
            const packageName = process.env.PACKAGE_NAME;
            const prTagPrefix = process.env.PR_TAG_PREFIX;
            const devTagPrefix = process.env.DEV_TAG_PREFIX;
            const branchName = context.payload?.ref?.replace(/^refs\/heads\//, '').replace(/\//g, '-');

            try {
              const versions = await github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg({
                package_type: 'container',
                package_name: packageName,
                org: context.repo.owner
              });

              const mainBuilds = [];

              for (const v of versions.data) {
                const tags = v.metadata?.container?.tags || [];

                const isTaggedRelease = tags.some(t => /^v\d+\.\d+\.\d+$/.test(t));
                const isMainDev = tags.some(t => t.startsWith(devTagPrefix));
                const isPR = branchName
                  ? tags.some(t => t.includes(branchName) || t.startsWith(prTagPrefix))
                  : tags.some(t => t.startsWith(prTagPrefix));
                const isUntagged = tags.length === 0;

                if (!isTaggedRelease && (isPR || isUntagged)) {
                  console.log(`Deleting helm chart version ${v.id} (tags: ${tags.join(', ') || 'untagged'})`);
                  await github.rest.packages.deletePackageVersionForOrg({
                    package_type: 'container',
                    package_name: packageName,
                    org: context.repo.owner,
                    package_version_id: v.id
                  });
                } else if (isMainDev) {
                  mainBuilds.push(v);
                }
              }

              mainBuilds.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
              const oldMain = mainBuilds.slice(5);
              for (const v of oldMain) {
                console.log(`Deleting old main helm chart ${v.id}`);
                await github.rest.packages.deletePackageVersionForOrg({
                  package_type: 'container',
                  package_name: packageName,
                  org: context.repo.owner,
                  package_version_id: v.id
                });
              }
            } catch (error) {
              if (error.status === 404) {
                console.log(`Helm chart package not found: ${error.message}`);
              } else {
                throw error;
              }
            }
